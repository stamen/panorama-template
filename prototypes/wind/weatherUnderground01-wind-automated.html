<!DOCTYPE html>
<head>
<meta charset="utf-8">
<title>Tahoe wind</title>
<style>

body {
	font: 12px "Helvetica Neue", Helvetica, Arial, sans-serif;
	background: #f9f9f9;
	color: #292929;
}

.content {
	
}

.windvane {
	fill: none;
	stroke: #ddb123;
}

.time-label {
	font-size: 2em;
	text-align: center;
}

.time-slider {
	
}

.axis {
	/* font: 10px sans-serif; */
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}


</style>
</head>

<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.14/d3.js"></script>
<script src="https://d3js.org/d3-queue.v2.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.2.1/lodash.min.js"></script>

<script>

/*
TODO: start with simple wind vector per timestep:
arrow pointing in direction / length of wind.

note that timesteps in WU data are uneven, so will have to have time move forward evenly in code
and interpolate between nearest data points.

make modular so we can place one of these for each point on the map for which WU/NWS has data.
add time scrubber to this and snotel.
 */

var body = document.querySelector('body');

var margin = { top: 10, right: 50, bottom: 10, left: 50 },
	containerWidth = 600, //body.offsetWidth
	containerHeight = 600, //body.offsetHeight
	width = containerWidth - margin.left - margin.right,
	height = containerHeight - margin.top - margin.bottom;

var container = d3.select('body').append('div')
	.attr('class', 'content')
	.style('width', width + margin.left + margin.right + 'px')
	.style('height', height + margin.top + margin.bottom + 'px');

var svg = container.html('').append('svg')
	.attr('width', width + margin.left + margin.right)
	.attr('height', height + margin.top + margin.bottom)
.append('g')
	.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

var dataSources = [
	{
		name: 'truckeeAirport',
		filename: '../data/truckeeAirport-met.csv',
		firstline: 3
	}
];
var keyMap = {
	// 'TimePST': 'localTime',
	// 'TemperatureF': 'temp',
	// 'Dew PointF': 'dew',
	// 'Humidity': 'humidity',
	// 'Sea Level PressureIn': 'pressure',
	// 'VisibilityMPH': 'visibility',
	// 'Wind Direction': 'windDirCompass',
	'Wind SpeedMPH': 'windSpeed',
	// 'Gust SpeedMPH': 'gustSpeed',
	// 'PrecipitationIn': 'precip',
	// 'Events': 'events',
	// 'Conditions': 'conditions',
	'WindDirDegrees': 'windDirDegrees',
	'DateUTC': 'date'
}
var dateFormatIn = d3.time.format('%Y-%m-%d %X'),
	dateFormatOut = d3.time.format('%Y %b %d %X');
var stationsData = {};

function loadStationData (source, cb) {

	d3.xhr(source.filename, function (err, rsp) {

		if (err) { throw err; }

		var stationName;
		try {
			rsp = rsp.responseText.split('\n');
			stationName = rsp[0].substr(2);
			rsp = rsp.slice(source.firstline - 1).join('\n');
			csv = d3.csv.parse(rsp);
		} catch (parsingError) {
			throw parsingError;
		}

		var timesteps = {},
			timestep,
			k;

		csv.forEach(function (d, i) {
			timestep = {};
			
			// select only the data we're using,
			// and make keys easier to work with
			for (key in keyMap) {
				k = keyMap[key];
				if (k === 'date') {
					// store unix timestamps instead of formatted date
					timestep[k] = +dateFormatIn.parse(d[key]);
				} else {
					timestep[k] = parseFloat(d[key]) || 0;
				}
			}

			timesteps[timestep.date] = timestep;
		});

		stationsData[source.name] = {
			name: stationName,
			stepsHash: timesteps,
			stepsList: _.values(timesteps)
		};
		cb();

	});
}

function quantizeStationData (data, startDate, endDate, dateInc) {
	var rawSteps = data.stepsList,
		quantizedSteps = [],
		prevDatum, nextDatum,
		stepsBetweenData,
		dateRatio,
		prevDatumVal,
		dAng,
		rawIndex = 0;

	for (var dateCtr=startDate; dateCtr<=endDate; dateCtr+=dateInc) {
		prevDatum = rawSteps[rawIndex];

		stepsBetweenData = 0;

		if (dateCtr < prevDatum.date) {
			nextDatum = prevDatum;
		} else if (rawIndex >= data.length - 1) {
			nextDatum = prevDatum;
		} else {
			nextDatum = rawSteps[rawIndex + 1];
			while (dateCtr >= nextDatum.date) {
				prevDatum = rawSteps[rawIndex + ++stepsBetweenData];
				nextDatum = rawSteps[rawIndex + 1 + stepsBetweenData];
			}
			rawIndex += stepsBetweenData;
		}

		dateRatio = Math.max(0, Math.min(1, (dateCtr - prevDatum.date) / (nextDatum.date - prevDatum.date)));
		quantizedSteps.push(_.values(keyMap).reduce(function (acc, key) {
			prevDatumVal = prevDatum[key];
			if (key === 'date') {
				acc[key] = dateCtr;
			} else if (typeof(prevDatumVal) === 'number') {
				if (key === 'windDirDegrees') {
					// interpolate degrees around 360
					dAng = nextDatum[key] - prevDatumVal;
					while (dAng < -180) { dAng += 360; }
					while (dAng > 180) { dAng -= 360; }
					acc[key] = prevDatumVal + dateRatio * dAng;
				} else {
					acc[key] = prevDatumVal + dateRatio * (nextDatum[key] - prevDatumVal);
				}
			} else {
				acc[key] = prevDatumVal;
			}
			return acc;
		}, {}));

		/*
		console.log("[date]  prev:", prevDatum.date, "step:", dateCtr, "next:", nextDatum.date, "ratio:", dateRatio);
		console.log("[speed] prev:", prevDatum.windSpeed, "step:", quantizedSteps[quantizedSteps.length-1].windSpeed, "next:", nextDatum.windSpeed);
		console.log("[dir]   prev:", prevDatum.windDirDegrees, "step:", quantizedSteps[quantizedSteps.length-1].windDirDegrees, "next:", nextDatum.windDirDegrees);
		*/
	}

	return quantizedSteps;
}


var queue = d3_queue.queue();
dataSources.forEach(function (source) {
	queue.defer(loadStationData, source)
});
queue.await(function () {

	var radius = 0.5 * width;
	var ampScale = d3.scale.linear()
		.range([0, radius])
		.domain([0, d3.max(stationsData.truckeeAirport.stepsList, function (d) { return d.windSpeed; })]);

	var windvane = svg.append('g')
		.attr('transform', 'translate(' + radius + ',' + radius + ')')
	.append('line')
		.classed('windvane', true)
		.attr('x1', 0)
		.attr('x2', 0)
		.attr('y1', 0)
		.attr('y2', 0);

	// quantize data into equal-length timesteps
	var dateExtent = d3.extent(stationsData.truckeeAirport.stepsList, function (d) { return d.date; }),
		currentDate = new Date(dateExtent[0]);
	currentDate.setHours(0);
	currentDate.setMinutes(0);
	currentDate.setSeconds(0);
	var dateInc = 60000 * 12;	// 12-min steps @ 60fps = 12 hours / sec
	var quantizedStepsList = quantizeStationData(stationsData.truckeeAirport, currentDate.getTime(), dateExtent[1], dateInc);

	function setDatum (datum) {
		windvane.datum(datum)
			.attr('y1', function (d) { return -0.5 * ampScale(d.windSpeed); })
			.attr('y2', function (d) { return 0.5 * ampScale(d.windSpeed); })
			.attr('transform', function (d) { return 'rotate(' + d.windDirDegrees + ')'; })

		timeLabel.datum(datum)
			.text(function (d) { return dateFormatOut(new Date(datum.date)); });
	}

	var currentStep = 0;
	var isAutoStepping = true;
	function step () {
		if (currentStep >= quantizedStepsList.length - 1) {
			isAutoStepping = false;
			return;
		}

		setDatum(quantizedStepsList[++currentStep]);
		if (isAutoStepping) {
			window.requestAnimationFrame(step);
		}
	}

	if (isAutoStepping) {
		window.requestAnimationFrame(step);
	}

	var timeLabel = container.append('div')
	.append('p')
		.classed('time-label', true);
	timeLabel.append('p')
		.text(stationsData.truckeeAirport.name);

	var timeSlider = container.append('div')
		.classed('time-slider', true)

});

</script>
