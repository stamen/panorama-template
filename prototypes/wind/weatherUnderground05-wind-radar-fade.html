<!DOCTYPE html>
<head>
<meta charset="utf-8">
<title>Tahoe wind</title>
<style>

body {
	font: 12px "Helvetica Neue", Helvetica, Arial, sans-serif;
	background: #f9f9f9;
	color: #292929;
}

.content {
	
}

.windvane {
	fill: #ddb123;
	stroke: none;
}

.time-label {
	font-size: 2em;
	text-align: center;
}

.time-slider {
	
}

.axis {
	/* font: 10px sans-serif; */
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}


</style>
</head>

<body>

<!--
[csvcut]
show that WindDirDegrees is always a multiple of 10:
$ tail -n +3 truckeeAirport-met.csv | csvcut -c 13 | csvgrep -c 1 -r ".*[^0]$" | csvlook
-->

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.14/d3.js"></script>
<script src="https://d3js.org/d3-queue.v2.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.2.1/lodash.min.js"></script>

<script>

var body = document.querySelector('body');

var margin = { top: 10, right: 50, bottom: 10, left: 50 },
	containerWidth = 600, //body.offsetWidth
	containerHeight = 600, //body.offsetHeight
	width = containerWidth - margin.left - margin.right,
	height = containerHeight - margin.top - margin.bottom;

var container = d3.select('body').append('div')
	.attr('class', 'content')
	.style('width', width + margin.left + margin.right + 'px')
	.style('height', height + margin.top + margin.bottom + 'px');

var svg = container.html('').append('svg')
	.attr('width', width + margin.left + margin.right)
	.attr('height', height + margin.top + margin.bottom)
.append('g')
	.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

var dataSources = [
	{
		name: 'truckeeAirport',
		filename: '../data/truckeeAirport-met.csv',
		firstline: 3
	}
];
var keyMap = {
	// 'TimePST': 'localTime',
	// 'TemperatureF': 'temp',
	// 'Dew PointF': 'dew',
	// 'Humidity': 'humidity',
	// 'Sea Level PressureIn': 'pressure',
	// 'VisibilityMPH': 'visibility',
	// 'Wind Direction': 'windDirCompass',
	'Wind SpeedMPH': 'windSpeed',
	// 'Gust SpeedMPH': 'gustSpeed',
	// 'PrecipitationIn': 'precip',
	// 'Events': 'events',
	// 'Conditions': 'conditions',
	'WindDirDegrees': 'windDirDegrees',
	'DateUTC': 'date'
}
var dateFormatIn = d3.time.format('%Y-%m-%d %X'),
	dateFormatOut = d3.time.format('%Y %b %d %X');
var stationsData = {};

function loadStationData (source, cb) {

	d3.xhr(source.filename, function (err, rsp) {

		if (err) { throw err; }

		var stationName;
		try {
			rsp = rsp.responseText.split('\n');
			stationName = rsp[0].substr(2);
			rsp = rsp.slice(source.firstline - 1).join('\n');
			csv = d3.csv.parse(rsp);
		} catch (parsingError) {
			throw parsingError;
		}

		var timesteps = {},
			timestep,
			k;

		csv.forEach(function (d, i) {
			timestep = {};
			
			// select only the data we're using,
			// and make keys easier to work with
			for (key in keyMap) {
				k = keyMap[key];
				if (k === 'date') {
					// store unix timestamps instead of formatted date
					timestep[k] = +dateFormatIn.parse(d[key]);
				} else {
					timestep[k] = parseFloat(d[key]) || 0;
				}
			}

			timesteps[timestep.date] = timestep;
		});

		stationsData[source.name] = {
			name: stationName,
			stepsHash: timesteps,
			stepsList: _.values(timesteps)
		};
		cb();

	});
}

function quantizeStationData (data, startDate, endDate, dateInc) {
	var rawSteps = data.stepsList,
		quantizedSteps = [],
		prevDatum, nextDatum,
		stepsBetweenData,
		dateRatio,
		prevDatumVal,
		dAng,
		rawIndex = 0;

	for (var dateCtr=startDate; dateCtr<=endDate; dateCtr+=dateInc) {
		prevDatum = rawSteps[rawIndex];

		stepsBetweenData = 0;

		if (dateCtr < prevDatum.date) {
			nextDatum = prevDatum;
		} else if (rawIndex >= data.length - 1) {
			nextDatum = prevDatum;
		} else {
			nextDatum = rawSteps[rawIndex + 1];
			while (dateCtr >= nextDatum.date) {
				prevDatum = rawSteps[rawIndex + ++stepsBetweenData];
				nextDatum = rawSteps[rawIndex + 1 + stepsBetweenData];
			}
			rawIndex += stepsBetweenData;
		}

		dateRatio = Math.max(0, Math.min(1, (dateCtr - prevDatum.date) / (nextDatum.date - prevDatum.date)));
		quantizedSteps.push(_.values(keyMap).reduce(function (acc, key) {
			prevDatumVal = prevDatum[key];
			if (key === 'date') {
				acc[key] = dateCtr;
			} else if (typeof(prevDatumVal) === 'number') {
				if (key === 'windDirDegrees') {
					// interpolate degrees around 360
					dAng = nextDatum[key] - prevDatumVal;
					while (dAng < -180) { dAng += 360; }
					while (dAng > 180) { dAng -= 360; }
					acc[key] = prevDatumVal + dateRatio * dAng;
				} else {
					acc[key] = prevDatumVal + dateRatio * (nextDatum[key] - prevDatumVal);
				}
			} else {
				acc[key] = prevDatumVal;
			}
			return acc;
		}, {}));

		/*
		console.log("[date]  prev:", prevDatum.date, "step:", dateCtr, "next:", nextDatum.date, "ratio:", dateRatio);
		console.log("[speed] prev:", prevDatum.windSpeed, "step:", quantizedSteps[quantizedSteps.length-1].windSpeed, "next:", nextDatum.windSpeed);
		console.log("[dir]   prev:", prevDatum.windDirDegrees, "step:", quantizedSteps[quantizedSteps.length-1].windDirDegrees, "next:", nextDatum.windDirDegrees);
		*/
	}

	return quantizedSteps;
}


var queue = d3_queue.queue();
dataSources.forEach(function (source) {
	queue.defer(loadStationData, source)
});
queue.await(function () {

	var radius = 0.5 * width,
		minCapSize = 2,
		maxCapSize = 0.05 * radius,
		numStepsVisible = 60,
		ampScale = d3.scale.linear()
			.domain([0, d3.max(stationsData.truckeeAirport.stepsList, function (d) { return d.windSpeed; })])
			.range([0, radius]),
		timeScale = d3.scale.pow().exponent(3)
			.domain([0, numStepsVisible - 1])
			.range([0.0, 1.0]);

	// data are in 10° increments
	var arcGenerator = d3.svg.arc()	
		.startAngle(function (d) { return (d.windDirDegrees - 5) / 180 * Math.PI; })
		.endAngle(function (d) { return (d.windDirDegrees + 5) / 180 * Math.PI; })
		.innerRadius(0)
		.outerRadius(function (d) { return ampScale(d.windSpeed); });

	var windvaneContainers = svg.append('g')
			.attr('transform', 'translate(' + radius + ',' + radius + ') rotate(-90)');	// rotate 90° to align x-axis with compass north

	// quantize data into equal-length timesteps
	var dateExtent = d3.extent(stationsData.truckeeAirport.stepsList, function (d) { return d.date; }),
		currentDate = new Date(dateExtent[0]);
	currentDate.setHours(0);
	currentDate.setMinutes(0);
	currentDate.setSeconds(0);
	var dateInc = 60000 * 12;	// 12-min steps @ 60fps = 12 hours / sec
	var quantizedStepsList = quantizeStationData(stationsData.truckeeAirport, currentDate.getTime(), dateExtent[1], dateInc);

	function setData (data) {

		var sel = windvaneContainers.selectAll('.windvane')
			.data(data);

		// update
		sel
			.attr('opacity', function (d, i) { return timeScale(i); })
			.attr('d', arcGenerator);

		// enter
		var windvane = sel.enter().append('path')
			.classed('windvane', true)
			.attr('d', arcGenerator);

		// exit
		sel.exit().remove();

		timeLabel.datum(data[data.length - 1])
			.text(function (d) { return dateFormatOut(new Date(d.date)); });
	}

	var isAutoStepping = true,
		currentStep = numStepsVisible,
		recentStepsList = quantizedStepsList.slice(0, numStepsVisible);

	function step () {
		if (currentStep >= quantizedStepsList.length - 1 - numStepsVisible) {
			isAutoStepping = false;
			return;
		}

		recentStepsList.shift();
		recentStepsList.push(quantizedStepsList[++currentStep]);
		setData(recentStepsList);
		if (isAutoStepping) {
			window.requestAnimationFrame(step);
		}
	}

	if (isAutoStepping) {
		window.requestAnimationFrame(step);
	}

	var timeLabel = container.append('div')
	.append('p')
		.classed('time-label', true);
	timeLabel.append('p')
		.text(stationsData.truckeeAirport.name);

	var timeSlider = container.append('div')
		.classed('time-slider', true)

});

</script>
