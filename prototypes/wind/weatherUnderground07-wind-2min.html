<!DOCTYPE html>
<head>
<meta charset="utf-8">
<title>Tahoe wind</title>
<style>

body {
	font: 12px "Helvetica Neue", Helvetica, Arial, sans-serif;
	background: #f9f9f9;
	color: #292929;
}

.content {
	
}

.windvane {
	fill: #ddb123;
	stroke-width: 4px;
}

.windvane-container {
	pointer-events: none;
}

.time-label {
	font-size: 2em;
	text-align: center;
}

.date-slider text {
	stroke: none;
	fill: #205D8C;
	text-align: center;
}
.date-slider .domain {
	stroke: #9DAFCC;
	stroke-width: 2px;
	stroke-linecap: round;
}
.date-slider .tick line {
	stroke: #9DAFCC;
	stroke-width: 2px;
	stroke-linecap: round;
}
.date-slider .thumb {
	stroke: #205D8C;
	stroke-width: 3px;
	stroke-linecap: round;
}

.axis {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none;
}

.axis path,
.axis line {
	fill: none;
	stroke: #000;
	shape-rendering: crispEdges;
}


</style>
</head>

<body>

<!--
[csvcut]
show that WindDirDegrees is always a multiple of 10:
$ tail -n +3 truckeeAirport-met.csv | csvcut -c 13 | csvgrep -c 1 -r ".*[^0]$" | csvlook
-->

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.14/d3.js"></script>
<script src="https://d3js.org/d3-queue.v2.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.2.1/lodash.min.js"></script>

<script>

var body = document.querySelector('body');

var margin = { top: 10, right: 50, bottom: 10, left: 50 },
	containerWidth = 600, //body.offsetWidth
	containerHeight = 600, //body.offsetHeight
	width = containerWidth - margin.left - margin.right,
	height = containerHeight - margin.top - margin.bottom;

var container = d3.select('body').append('div')
	.attr('class', 'content')
	.style('width', width + margin.left + margin.right + 'px')
	.style('height', height + margin.top + margin.bottom + 'px');

var svg = container.html('').append('svg')
	.attr('width', width + margin.left + margin.right)
	.attr('height', height + margin.top + margin.bottom)
.append('g')
	.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

var dataSources = [
	{
		name: 'truckeeAirport',
		filename: '../data/truckeeAirport-met.csv',
		firstline: 3
	}
];
var keyMap = {
	// 'TimePST': 'localTime',
	// 'TemperatureF': 'temp',
	// 'Dew PointF': 'dew',
	// 'Humidity': 'humidity',
	// 'Sea Level PressureIn': 'pressure',
	// 'VisibilityMPH': 'visibility',
	// 'Wind Direction': 'windDirCompass',
	'Wind SpeedMPH': 'windSpeed',
	// 'Gust SpeedMPH': 'gustSpeed',
	// 'PrecipitationIn': 'precip',
	// 'Events': 'events',
	// 'Conditions': 'conditions',
	'WindDirDegrees': 'windDirDegrees',
	'DateUTC': 'date'
}
var dateFormatIn = d3.time.format('%Y-%m-%d %X'),
	dateFormatOut = d3.time.format('%Y %b %d %X');
var stationsData = {};

function loadStationData (source, cb) {

	d3.xhr(source.filename, function (err, rsp) {

		if (err) { throw err; }

		var stationName;
		try {
			rsp = rsp.responseText.split('\n');
			stationName = rsp[0].substr(2);
			rsp = rsp.slice(source.firstline - 1).join('\n');
			csv = d3.csv.parse(rsp);
		} catch (parsingError) {
			throw parsingError;
		}

		var timesteps = {},
			timestep,
			k;

		csv.forEach(function (d, i) {
			timestep = {};
			
			// select only the data we're using,
			// and make keys easier to work with
			for (key in keyMap) {
				k = keyMap[key];
				if (k === 'date') {
					// store unix timestamps instead of formatted date
					timestep[k] = +dateFormatIn.parse(d[key]);
				} else {
					timestep[k] = parseFloat(d[key]) || 0;
				}
			}

			timesteps[timestep.date] = timestep;
		});

		stationsData[source.name] = {
			name: stationName,
			stepsHash: timesteps,
			stepsList: _.values(timesteps)
		};
		cb();

	});
}

function quantizeStationData (data, startDate, endDate, dateInc) {
	var rawSteps = data.stepsList,
		quantizedSteps = [],
		prevDatum, nextDatum,
		stepsBetweenData,
		dateRatio,
		prevDatumVal,
		dAng,
		rawIndex = 0;

	for (var dateCtr=startDate; dateCtr<=endDate; dateCtr+=dateInc) {
		prevDatum = rawSteps[rawIndex];

		stepsBetweenData = 0;

		if (dateCtr < prevDatum.date) {
			nextDatum = prevDatum;
		} else if (rawIndex >= data.length - 1) {
			nextDatum = prevDatum;
		} else {
			nextDatum = rawSteps[rawIndex + 1];
			while (dateCtr >= nextDatum.date) {
				prevDatum = rawSteps[rawIndex + ++stepsBetweenData];
				nextDatum = rawSteps[rawIndex + 1 + stepsBetweenData];
			}
			rawIndex += stepsBetweenData;
		}

		dateRatio = Math.max(0, Math.min(1, (dateCtr - prevDatum.date) / (nextDatum.date - prevDatum.date)));
		quantizedSteps.push(_.values(keyMap).reduce(function (acc, key) {
			prevDatumVal = prevDatum[key];
			if (key === 'date') {
				acc[key] = dateCtr;
			} else if (typeof(prevDatumVal) === 'number') {
				if (key === 'windDirDegrees') {
					// interpolate degrees around 360
					dAng = nextDatum[key] - prevDatumVal;
					while (dAng < -180) { dAng += 360; }
					while (dAng > 180) { dAng -= 360; }
					acc[key] = prevDatumVal + dateRatio * dAng;
				} else {
					acc[key] = prevDatumVal + dateRatio * (nextDatum[key] - prevDatumVal);
				}
			} else {
				acc[key] = prevDatumVal;
			}
			return acc;
		}, {}));

		/*
		console.log("[date]	prev:", prevDatum.date, "step:", dateCtr, "next:", nextDatum.date, "ratio:", dateRatio);
		console.log("[speed] prev:", prevDatum.windSpeed, "step:", quantizedSteps[quantizedSteps.length-1].windSpeed, "next:", nextDatum.windSpeed);
		console.log("[dir]	 prev:", prevDatum.windDirDegrees, "step:", quantizedSteps[quantizedSteps.length-1].windDirDegrees, "next:", nextDatum.windDirDegrees);
		*/
	}

	return quantizedSteps;
}


var queue = d3_queue.queue();
dataSources.forEach(function (source) {
	queue.defer(loadStationData, source)
});
queue.await(function () {

	var radius = 0.5 * width,
		minCapSize = 2,
		maxCapSize = 0.05 * radius,
		numStepsVisible = 60,
		ampScale = d3.scale.linear()
			.domain([0, d3.max(stationsData.truckeeAirport.stepsList, function (d) { return d.windSpeed; })])
			.range([0, radius]),
		timeScale = d3.scale.pow().exponent(3)
			.domain([0, numStepsVisible - 1])
			.range([0.0, 1.0]);

	// data are in 10° increments
	var arcGenerator = d3.svg.arc()	
		.startAngle(function (d) { return (d.windDirDegrees - 5) / 180 * Math.PI; })
		.endAngle(function (d) { return (d.windDirDegrees + 5) / 180 * Math.PI; })
		.innerRadius(0)
		.outerRadius(function (d) { return ampScale(d.windSpeed); });

	var windvaneContainers = svg.append('g')
			.classed('windvane-container', true)
			.attr('transform', 'translate(' + radius + ',' + radius + ') rotate(-90)');	// rotate 90° to align x-axis with compass north

	// quantize data into equal-length timesteps
	var dateExtent = d3.extent(stationsData.truckeeAirport.stepsList, function (d) { return d.date; }),
		currentDate = new Date(dateExtent[0]);
	currentDate.setHours(0);
	currentDate.setMinutes(0);
	currentDate.setSeconds(0);
	// var dateInc = 60000 * 12;	// 12-min steps @ 60fps = 12 hours / sec
	var dateInc = 60000 * 2;	// 2-min steps @ 60fps = 2 hours / sec
	var quantizedStepsList = quantizeStationData(stationsData.truckeeAirport, currentDate.getTime(), dateExtent[1], dateInc);

	function setData (data) {

		var sel = windvaneContainers.selectAll('.windvane')
			.data(data);

		// update
		sel
			.attr('opacity', function (d, i) { return timeScale(i); })
			.attr('stroke', function (d, i) { return i === sel.size() - 1 ? '#b28f1c' : 'none'; })
			.attr('d', arcGenerator);

		// enter
		var windvane = sel.enter().append('path')
			.classed('windvane', true)
			.attr('d', arcGenerator);

		// exit
		sel.exit().remove();

		timeLabel.datum(data[data.length - 1])
			.text(function (d) { return dateFormatOut(new Date(d.date)); });
	}

	var isAutoStepping = true,
		currentStep = numStepsVisible,
		recentStepsList = quantizedStepsList.slice(0, numStepsVisible),
		currentRAF;

	function step () {
		if (currentStep >= quantizedStepsList.length - 1 - numStepsVisible) {
			isAutoStepping = false;
			return;
		}

		recentStepsList.shift();
		recentStepsList.push(quantizedStepsList[++currentStep]);
		setData(recentStepsList);
		if (isAutoStepping) {
			currentRAF = window.requestAnimationFrame(step);
		}
	}

	function jumpToStep (targetStep) {
		currentStep = targetStep;
		recentStepsList = quantizedStepsList.slice(currentStep, currentStep + numStepsVisible);
		isAutoStepping = true;
		window.cancelAnimationFrame(currentRAF);
		currentRAF = window.requestAnimationFrame(step);
	}

	if (isAutoStepping) {
		currentRAF = window.requestAnimationFrame(step);
	}


	var clickLayer = svg.insert('rect', 'g')
		.attr('width', width)
		.attr('height', height)
		.attr('fill', 'blue')
		.attr('fill-opacity', 0.0);
	clickLayer.on('click', function () {
		isAutoStepping = !isAutoStepping;
		if (isAutoStepping) {
			currentRAF = window.requestAnimationFrame(step);
		}
	});


	var timeLabel = container.append('div')
	.append('p')
		.classed('time-label', true);
	timeLabel.append('p')
		.text(stationsData.truckeeAirport.name);


	//
	// date slider
	// 
	var dateScale = d3.time.scale()
			.domain(dateExtent)
			.range([0, width])
			.clamp(true),
		stepsListDateScale = d3.time.scale()
			.domain([currentDate.getTime(), dateExtent[1]])
			.rangeRound([0, quantizedStepsList.length-1]);
	var dateFormatSliderAxis = d3.time.format('%Y'),
		dateFormatSliderThumb = d3.time.format('%b %d');

	var brushGenerator = d3.svg.brush()
		.x(dateScale)
		.extent([currentDate, currentDate])
		.on('brush', onBrush);

	var sliderHeight = 100,
		sliderContainer = container.append('svg')
			.attr('width', width + margin.left + margin.right)
			.attr('height', sliderHeight)
		.append('g')
			.attr('transform', 'translate(' + margin.left + ',0)')
			.classed('date-slider', true);

	sliderContainer.append('g')
		.classed('x axis', true)
		.attr('transform', 'translate(0,' + 0.5*sliderHeight + ')')
		.call(d3.svg.axis()
			.scale(dateScale)
			.orient('bottom')
			.ticks(d3.time.years, 1)
			.tickSize(5, 0)
			.tickPadding(12)
			.tickFormat(function (d) { return dateFormatSliderAxis(d); }));

	var dateSlider = sliderContainer.append('g')
		.call(brushGenerator);

	dateSlider.selectAll('.extent, .resize').remove();

	dateSlider.select('.background')
		.attr('height', sliderHeight);

	var thumb = dateSlider.append('g')
		.classed('thumb', true);
	thumb.append('path')
		.attr('transform', 'translate(0,' + 0.5*sliderHeight + ')')
		.attr('d', 'M 0 -10 V 10');
	thumb.append('text')
		.text(currentDate)
		.attr('transform', 'translate(-15,25)');

	dateSlider.call(brushGenerator.event);

	function onBrush () {
		var value = brushGenerator.extent()[0];

		// user-generated event
		if (d3.event.sourceEvent) {
			value = dateScale.invert(d3.mouse(this)[0]);
			brushGenerator.extent([value, value]);
			jumpToStep(stepsListDateScale(value));
		}

		thumb.attr('transform', 'translate(' + dateScale(value) + ',0)');
		thumb.select('text').text(dateFormatSliderThumb(value));
	}

});

</script>
