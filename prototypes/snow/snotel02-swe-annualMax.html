<!DOCTYPE html>
<head>
<meta charset="utf-8">
<title>Tahoe snow data</title>
<style>

body {
	font: 12px "Helvetica Neue", Helvetica, Arial, sans-serif;
	background: #f9f9f9;
	color: #292929;
}

.content {
	
}

.swe {
	fill: #d3e6ff;
	stroke: none;
}

.swe-max-current {
	fill: none;
	stroke: #ff6600;
	opacity: 1;
	transition: opacity 1s ease;
}
.swe-max-current.hidden {
	opacity: 0;
}

.swe-max-annual circle {
	fill: #f9f9f9;
	stroke: #ff6600;
	stroke-width: 2;

	cursor: pointer;
}
.swe-max-annual path {
	fill: none;
	stroke: #ff6600;
	stroke-width: 1;
}

.time-label {
	font-size: 2em;
	text-align: center;
}

.time-slider {
	
}

.axis {
	/* font: 10px sans-serif; */
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}


</style>
</head>

<body>


<!--

TODO: SNOTEL data -- bar graph animated by timeline scrubber or autoplay.
somehow represent deviation between steps (#7 Precip Inc) (to show snowfall events)
make it work for multiple data stations.

SWE compared with depth.
(where is depth??)
show temp too?

[csvcut]
skip comments header:
$ tail -n +8 heavenly-snotel.csv | csvcut -n
show that SWE is always 0 on sept 01:
$ tail -n +8 heavenly-snotel.csv | csvcut -c 1,2 | csvgrep -c 1 -r "^\d{4}-09-01$" | csvlook

-->



<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.14/d3.js"></script>
<script src="https://d3js.org/d3-queue.v2.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.2.1/lodash.min.js"></script>

<script>

var body = document.querySelector('body');

var margin = { top: 10, right: 50, bottom: 50, left: 50 },
	width = 600/*body.offsetWidth*/ - margin.left - margin.right,
	height = 600/*body.offsetHeight*/ - margin.top - margin.bottom;

var container = d3.select('body').append('div')
	.attr('class', 'content')
	.style('width', width + margin.left + margin.right + 'px')
	.style('height', height + margin.top + margin.bottom + 'px');

var svg = container.html('').append('svg')
	.attr('width', width + margin.left + margin.right)
	.attr('height', height + margin.top + margin.bottom)
.append('g')
	.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

var dataSources = [
	{
		name: 'heavenly',
		filename: '../data/heavenly-snotel.csv',
		firstline: 8
	}
];
var keyMap = {
	'Air Temperature Average (degF)': "tempAvg",
	'Air Temperature Maximum (degF)': "tempMax",
	'Air Temperature Minimum (degF)': "tempMin",
	'Date': "date",
	'Precipitation Accumulation (in)': "precipAcc",
	'Precipitation Increment (in)': "precipInc",
	'Snow Water Equivalent (in)': "swe"
}
var dateFormatIn = d3.time.format('%Y-%m-%d'),
	dateFormatOut = d3.time.format('%Y %b %d');
var stationsData = {};

function loadStationData (source, cb) {

	d3.xhr(source.filename, function (err, rsp) {

		if (err) { throw err; }

		var stationName;
		try {
			rsp = rsp.responseText.split('\n');
			stationName = rsp[0].substr(2);
			rsp = rsp.slice(source.firstline - 1).join('\n');
			csv = d3.csv.parse(rsp);
		} catch (parsingError) {
			throw parsingError;
		}

		var timesteps = {},
			timestep,
			k;

		csv.forEach(function (d, i) {
			timestep = {};
			
			// make keys easier to work with
			for (key in keyMap) {
				k = keyMap[key];
				if (k === 'date') {
					// store unix timestamps instead of formatted date
					timestep[k] = +dateFormatIn.parse(d[key]);
				} else {
					timestep[k] = parseFloat(d[key]);
				}
			}

			timesteps[timestep.date] = timestep;
		});

		stationsData[source.name] = {
			name: stationName,
			stepsHash: timesteps,
			stepsList: _.values(timesteps)
		};
		cb();

	});
}


var queue = d3_queue.queue();
dataSources.forEach(function (source) {
	queue.defer(loadStationData, source)
});
queue.await(function () {

	var barWidth = 400;
	var xScale = d3.time.scale()
		.range([0.5 * (width - barWidth), 0.5 * (width + barWidth)])
		.domain([stationsData.heavenly.stepsList[0].date, stationsData.heavenly.stepsList[stationsData.heavenly.stepsList.length-1].date]);
	var yScale = d3.scale.linear()
		.range([height, 0])
		.domain([0, d3.max(stationsData.heavenly.stepsList, function (d) { return d.swe; })]);

	var xAxis = d3.svg.axis()
		.scale(xScale);
	svg.append('g')
		.classed('x axis', true)
		.attr('transform', 'translate(0,' + height + ')')
		.call(xAxis);
	var yAxis = d3.svg.axis()
		.scale(yScale)
		.orient('left');
	svg.append('g')
		.classed('y axis', true)
		.call(yAxis)
	.append("text")
		.attr("transform", "rotate(-90)")
		.attr("y", 6)
		.attr("dy", ".71em")
		.style("text-anchor", "end")
		.text("snow water equivalent (inches)");

	var annualMaxLineGenerator = d3.svg.line()
		.x(function (d) { return xScale(d.date); })
		.y(function (d) { return yScale(d.swe); })
		.interpolate('monotone');

	var currentYearMax = {
		date: 0,
		swe: 0
	};
	var currentYear = new Date(stationsData.heavenly.stepsList[0].date).getYear();
	var annualMaxes = [];

	var sweBar = svg.append('rect')
		.classed('swe', true)
	.attr('x', 0.5 * (width - barWidth))
	.attr('width', barWidth)

	var sweMaxLine = svg.append('line')
		.classed('swe-max-current', true)
		.classed('hidden', true)
		.attr('x1', 0.5 * (width - barWidth))
		.attr('x2', 0.5 * (width + barWidth))
		.attr('y1', 0)
		.attr('y2', 0);

	svg.append('g')
		.classed('swe-max-annual', true);

	var sweMaxPath = d3.select('.swe-max-annual').append('path')
		.datum(annualMaxes)
		.attr('d', annualMaxLineGenerator);

	function updateAnnualMaxes () {
		var sweMaxDots = d3.select('.swe-max-annual')
		.selectAll('circle')
			.data(annualMaxes);
		sweMaxDots.enter().append('circle')
			// .on('mouseover', onMaxDotOver)
			.attr('cx', function (d) { return xScale(d.date); })
			.attr('cy', function (d) { return yScale(d.swe); })
			.attr('r', 5)
		.append('title')
			.text(function (d) { return '[' + dateFormatOut(new Date(d.date)) + '] ' + d.swe + ' SWE'; });
		sweMaxDots.exit().remove();

		var sweMaxPath = d3.select('.swe-max-annual')
		.selectAll('path')
			.datum(annualMaxes)
			.attr('d', annualMaxLineGenerator);
	}

	function scaledHeight (d) { return yScale(d.swe); }
	function setDatum (datum) {
		var date = new Date(datum.date),
			isYearRecord = false;
		if (date.getYear() > currentYear && date.getMonth() >= 8) {
			// update annual maxes in September
			annualMaxes.push(currentYearMax);
			updateAnnualMaxes();
			currentYear = date.getYear();
			currentYearMax = {
				date: datum.date,
				swe: datum.swe
			};
			sweMaxLine.classed('hidden', true);
		}
		if (datum.swe > currentYearMax.swe) {
			currentYearMax = {
				date: datum.date,
				swe: datum.swe
			};
			isYearRecord = true;
		}

		sweBar.datum(datum)
			.attr('y', scaledHeight)
			.attr('height', function (d) { return height - yScale(d.swe); });

		if (isYearRecord) {
			sweMaxLine
				.classed('hidden', false)
			.datum(datum)
				.attr('y1', scaledHeight)
				.attr('y2', scaledHeight);
		}

		timeLabel.datum(datum)
			.text(function (d) { return dateFormatOut(date); });
	}

	var currentStep = 0;
	var isAutoStepping = true;
	function step () {
		setDatum(stationsData.heavenly.stepsList[++currentStep]);
		if (isAutoStepping) {
			window.requestAnimationFrame(step);
		}
	}

	if (isAutoStepping) {
		window.requestAnimationFrame(step);
	}

	var timeLabel = container.append('div')
	.append('p')
		.classed('time-label', true);
	timeLabel.append('p')
		.text(stationsData.heavenly.name);

	var timeSlider = container.append('div')
		.classed('time-slider', true);

});

</script>
